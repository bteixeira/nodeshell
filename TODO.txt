ROADMAP
=======
V. Basic Autocomplete
V. Allow redefining the prompt through API
V. Allow running user script on startup
4. Remaining exceptions -> Always a stack trace on exit due to file close. Do some heavy testing and try to find more.
5. Clean and put more tests in place. Create a stable release.

W. Aliases (this might need the Commands rewrite...)
X. Tokenizer. Must deliver sequence of tokens and not AST directly. Must detect unfinished tokens (needed for multi-line
    and proper autocomplete). Must consider paths and that it is possible to run an executable on this or another
    directory.
Y. Multi-line input
Z. Autocomplete overhaul
-. V Let prompt have colors (this will be nice to show the branch name)
-. Allow storing the output of commands. I want to do "git symbolic-ref --short -q HEAD" to get the branch name (only
    works on recent versions of git)

-. Must have most functionality of other shells.
    -. Job control, start job in bg with &
    -. Redirect output to file
    -. Pipe output between commands
    -. Support | and & operators
-. Then integate it with nsh principles
    -. Commands and functions should be almost the same
    -. Allow buffering the output of commands in variables or as streams
    -. Allow piping command output to function arguments
    -. Likewise, allow running JS and pipe the result to a command or a file
-. Then, impress (even more)
    -. Screen windows
    -. As-you-type autocomplete
    -. As-you-type syntax highlighting

EXCEPTIONS & PROBLEMS
=====================

* On CTRL+C or CTRL+D
* On cd to nonexistent dir
* require('colors') does not allow 'lalla'.red, probably something to do with different environments (String.prototype
    is not the same in nodeland and userland)
* Typing "cd ~/wo<TAB>" throws exception because autocompleter is assuming that ./~ is the name of a dir. Make it
    tolerate non-existent dirs and expand ~

IDEA HEAP
=========

Get a list of which common commands might be confusingly mistaken for plain JS. It's annoying to write a JS expression
    that starts with 'true' or 'false' and seems to return a wrong result. Another example is 'id = ...'. Have a visual
    signal for the user of whether the expression was interpreted as a command or JS.

Piping output
	ls | function wc(list) {console.log(list.length);}

There must be a way to pipe the output of a command into a variable, or even to get it inline

I want to have a status line with completions and such. One way to achieve this would be to have virtual windows on the
    screen, have (rectangular) areas with different content and assign the line reader to one of them.

I want completion as user is typing. Show list of possible commands like I3 does. Do the same for possible completions
    of everything else.

I want on-the-fly highlighting. Show the command and arguments in different colors. Highlight Javascript.

If the prompt is a function and not a string like in other shells, that's really nice because it's powerful but if that
    is a blocking or never-ending function then everything crumbles down.

Make Javascript be the means to something and not a dictator. CoffeeScript and such should be easy to integrate. There
    should be examples and/or plugins to show how to be able to use CoffeeScript as the main language.

There will be some performance concerns. There is lots of as-you-type processing. Try this out on a RaspberryPi and do
    some performance tests, see how many times per second it can parse a complex multi-line input.

Currently, user files can only have JS. Consider if it would nice to support also commands and anything you could run on
    the command line.


Architecture
============

Input
    gets keystrokes, there is a mapping of key to functionality

Parser
    the functionality to accept the command (enter key) instructs to pass the current line(s) to the parser
    The parser extracts a command plus arguments, or runs JS

Environment
    There must be an API with access to:
        all the commands as functions (and everything that is in the path)
        all the nodejs globals, including process, buffer, require, etc
        a set of objects that allow overriding behaviour and attaching event handlers; even the parser should be
        available in this way. Make it such that you can override or extend parts of the parsing, or all of it together
        (dangerous, but let's think about it later)

Builtins
    cd
    'source'
        (could be a command or something like '.' ?) (or 'require' ^^)
    alias
        for compat
    bg, fg, jobs
        let's think about it later
    exit
    mkdir ?
        isn't this in the path?
    print/echo
        compat?
    read?
        useful?
    umask?
    which?
    where?
    help?
        never hurts

Should we include most of the built ins from bash and zsh to allow maximum compat? should there be some compatibility
mode that emulated them? this could probably be achieved easily.


API
===

global object NSH where all the API is

task: define key binding
task: set the prompt
task: define aliases
task: set event handler for before exit
task: override the default parser or part of it
