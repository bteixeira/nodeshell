ROADMAP
=======
V. Basic Autocomplete
V. Allow redefining the prompt through API
V. Allow running user script on startup
4. Remaining exceptions -> Always a stack trace on exit due to file close. Do some heavy testing and try to find more.
5. Clean and put more tests in place. Create a stable release.

W. Aliases (this might need the Commands rewrite...)
X. Tokenizer. Must deliver sequence of tokens and not AST directly. Must detect unfinished tokens (needed for multi-line
    and proper autocomplete). Must consider paths and that it is possible to run an executable on this or another
    directory.
Y. Multi-line input
Z. Autocomplete overhaul
-. V Let prompt have colors (this will be nice to show the branch name)
-. Allow storing the output of commands. I want to do "git symbolic-ref --short -q HEAD" to get the branch name (only
    works on recent versions of git)

-. Must have most functionality of other shells.
    -. Job control, start job in bg with &
    ^. Redirect output to file
    ^. Pipe output between commands
    -. Support || and && operators
    ^. Aliases
    ^. Multi-line input
-. Then integrate it with nsh principles
    -. Commands and functions should be almost the same
    -. Allow buffering the output of commands in variables or as streams
    -. Allow piping command output to function arguments
    -. Likewise, allow running JS and pipe the result to a command or a file
-. Then, impress (even more)
    -. Screen windows
    -. As-you-type autocomplete
    -. As-you-type syntax highlighting

EXCEPTIONS & PROBLEMS
=====================

* On CTRL+C or CTRL+D
* On cd to nonexistent dir
* require('colors') does not allow 'lalla'.red, probably something to do with different environments (String.prototype
    is not the same in nodeland and userland)
* Typing "cd ~/wo<TAB>" throws exception because autocompleter is assuming that ./~ is the name of a dir. Make it
    tolerate non-existent dirs and expand ~

IDEA HEAP
=========

Get a list of which common commands might be confusingly mistaken for plain JS. It's annoying to write a JS expression
    that starts with 'true' or 'false' and seems to return a wrong result. Another example is 'id = ...'. Have a visual
    signal for the user of whether the expression was interpreted as a command or JS.

Piping output
	ls | function wc(list) {console.log(list.length);}

There must be a way to pipe the output of a command into a variable, or even to get it inline

I want to have a status line with completions and such. One way to achieve this would be to have virtual windows on the
    screen, have (rectangular) areas with different content and assign the line reader to one of them.

I want completion as user is typing. Show list of possible commands like I3 does. Do the same for possible completions
    of everything else.

I want on-the-fly highlighting. Show the command and arguments in different colors. Highlight Javascript.

If the prompt is a function and not a string like in other shells, that's really nice because it's powerful but if that
    is a blocking or never-ending function then everything crumbles down.

Make Javascript be the means to something and not a dictator. CoffeeScript and the like should be easy to integrate.
    There should be examples and/or plugins to show how to be able to use CoffeeScript as the main language.

There will be some performance concerns. There is lots of as-you-type processing. Try this out on a RaspberryPi and do
    some performance tests, see how many times per second it can parse a complex multi-line input.

Currently, user files can only have JS. Consider if it would nice to support also commands and anything you could run on
    the command line.

    ALIASES
    -------

    Aliases are tricky. Here is how it works in bash:

        alias rm="rm -i"

    Every time "rm" is typed, it is expanded into the body. Or so the docs say. In practice it is probably only expanded
    if found where a command is supposed to be, which is fine. The hassle for NSH is: when should it be expanded.
    Ideally it should be handled by Commands. However, an alias does not simply rename a command, it can also have
    preset arguments. Sure we can have aliases as functions to solve all these problems -- that's how the builtins are
    implemented.

        nsh.alias('gco', function(){ nsh.commands.get('git').run(['checkout'].concat(arguments));})

    I don't wanna have to write this every time.

    Alternative 1: the "alias" command/function takes a string. That string is evaluated immediately and separated into
    command and arguments. This has the implication that the command has to be defined at the time, unlike in bash. When
    the alias is invoked, it simply calls the aliased command with whatever arguments are passed at invocation, plus any
    aliased arguments before them.

    Alternative 2: during parsing, if the first token is a command, and if it is an alias, then it is expanded, and the
    parsing restarts, without alias expansion. The Parser would have to query Commands to check for valid aliases.


Architecture
============

Input
    gets keystrokes, there is a mapping of key to functionality

Parser
    the functionality to accept the command (enter key) instructs to pass the current line(s) to the parser
    The parser extracts a command plus arguments, or runs JS

Environment
    There must be an API with access to:
        all the commands as functions (and everything that is in the path)
        all the nodejs globals, including process, buffer, require, etc
        a set of objects that allow overriding behaviour and attaching event handlers; even the parser should be
        available in this way. Make it such that you can override or extend parts of the parsing, or all of it together
        (dangerous, but let's think about it later)

Builtins
    cd
    'source'
        (could be a command or something like '.' ?) (or 'require' ^^)
    alias
        for compat
    bg, fg, jobs
        let's think about it later
    exit
    mkdir ?
        isn't this in the path?
    print/echo
        compat?
    read?
        useful?
    umask?
    which?
    where?
    help?
        never hurts

Should we include most of the built ins from bash and zsh to allow maximum compat? should there be some compatibility
mode that emulated them? this could probably be achieved easily.


API
===

global object NSH where all the API is

task: define key binding
task: set the prompt
task: define aliases
task: set event handler for before exit
task: override the default parser or part of it



RESEARCH
========
BASH: Possible IO redirection operations:
    M>N
        M is fd (optional, default = 1)
        N is filename
        will truncate N if exists, create otherwise
        can have whitespace after > (not before)
    M>>N
        M is fd (optional, default = 1)
        N is filename
        will append to N if exists, create otherwise
        can have whitespace after >> (not before)
    M>&N
        M is fd (optional, default = 1)
        N is fd
        can have whitespace after >& (not before)
    M<N
        M is fd (optional, default = 0)
        N is filename
        can have whitespace after < (not before)
    M<&N
        M is fd (optional, default = 0)
        N is fd
        can have whitespace after <& (not before)
    M<>N
        M is fd (optional, default = 0)
        N is filename
        assigns N to M both for reading and writing

    note that << starts heredoc and will do nothing for redirection

Other Bash operators
    |
    &
    ||
    &&
    "

This works in bash:
    false && echo "yes" || echo "no"
    true  && echo "yes" || echo "no"

Tentative grammar...
(! is terminal)


    COMMAND_LINE:
        SUBSHELL

    PATH:
        !RELATIVE_PATH
        !ABSOLUTE_PATH
        !DOTS_PATH
        !TILDE_PATH

    PIPELINE:
        SIMPLE_COMMAND
        SIMPLE_COMMAND !PIPE PIPELINE

    SIMPLE_COMMAND:
        REDIRECTION* PATH (REDIRECTION | !GLOB | !JS | !DQSTRING | PATH)*

    REDIRECTION:
        !GT PATH
        !GTGT PATH
        !GTAMP FD
        !LT PATH
        !LTGT PATH
        !LTAMP FD

    FD:
        [0-9]+

    LIST:
        AND_LIST
        OR_LIST

    AND_LIST:
        PIPELINE
        PIPELINE DAMP LIST

    OR_LIST:
        PIPELINE
        PIPELINE DPIPE LIST

    SUBSHELL:
        LIST
        LIST AMP
        LIST AMP SUBSHELL



http://www.cs.binghamton.edu/~zdu/parsdemo/srintro.html