All builtins and syntax that must be supported by shell syntax
==============================================================

General command calling with arguments (getDir is a JS function)
	cd getDir()

Piping output
	ls | function wc(list) {console.log(list.length);}

Calling already existent commands
	git stash pop


Challenges
==========

The challenge is always to efficiently determine where arguments end
	git function () {return "merge";  } ( ) features/blablabla
	

What should this do?
	$ ls = 300
	$ ls
	
	Should it list directories or print the value of ls?
	A: let's let the command always have precedence, user can e.g. console.log(ls)
	or something else. otherwise user would be able to ofuscate basic commands
	very easily and bring the shell to an unusable state

What happens when there is a command called "3"?
A: again, let's assume it's a command. I have never seen commands with number as
name but if there is one, we want to be able to run it.

"Can your shell show man pages?"
  --> YES IT CAN


Architecture
============

Input
    gets keystrokes, there is a mapping of key to functionality

Parser
    the functionality to accept the command (enter key) instructs to pass the current line(s) to the parser
    The parser extracts a command plus arguments, or runs JS

Environment
    There must be an API with access to:
        all the commands as functions (and everything that is in the path)
        all the nodejs globals, including process, buffer, require, etc
        a set of objects that allow overriding behaviour and attaching event handlers; even the parser should be
        available in this way. Make it such that you can override or extend parts of the parsing, or all of it together
        (dangerous, but let's think about it later)

Builtins
    cd
    'source'
        (could be a command or something like '.' ?)
    alias
        for compat
    bg, fg, jobs
        let's think about it later
    exit
    mkdir ?
        isn't this in the path?
    print/echo
        compat?
    kill
        useful, might be the first thing you remember in an emergency
    read?
        useful?
    umask?
    whish?
    where?
    help?
        never hurts

Should we include most of the built ins from bash and zsh to allow maximum compat? should there be some compatibility mode that emulated them? this could probably be achieved easily.